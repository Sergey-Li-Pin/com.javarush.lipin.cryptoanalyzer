Вступление. Я люблю делать записи. Причем не важно - рукописные или пиксели на экране. Ведь всегда можно вернуться к ним и прочесть то, что я там мыслил час назад, вчера или на прошлой неделе. Такая практика позволяет мне не упускать то, что возможно забыть или вспомнить с ошибками. Так уж устроена человеческая память. Такой уж я забывчивый.

Начинаю делать программу для шифровки текста. Сначала пытаюсь понять как вообще работает шифрование. Нужно сдвигать буквы на какое-то число позиций - это и будет ключ. 

Brute force - это когда перебираешь все возможные сдвиги, пока не найдёшь тот, который даст нормальный текст.

Подход к алфавиту - по заданию нужны только русские буквы и основные символы пунктуации. Алфавит будет состоять из 33 русских букв в нижнем регистре и символов: . , " : - ! ? и пробел. Итого 41 символ. Так программа станет проще и понятнее. Забыл про важную деталь - регистр букв! Если в тексте будут большие буквы 'А', 'Н' и т.д., моя текущая реализация их не зашифрует, так как в алфавите только маленькие буквы. Нужно это учесть.

Буду определять регистр каждой буквы перед шифрованием. Если буква большая - запомню этот факт, преобразую в маленькую, зашифрую, а потом верну в большой регистр. Так алфавит останется из 41 символа, но программа будет работать с любым регистром.

Для символов пунктуации регистр не важен, их обрабатываю как есть.

С brute force вроде понятно - по заданию не нужно чтобы программа сама находила правильный ключ, достаточно сохранить все варианты в файлы. Пользователь потом сам посмотрит и выберет. Это проще, так как не нужно думать как машина поймёт что текст "нормальный".

Структура программы: сделаю консольное приложение. Сначала спросит что делать: зашифровать, расшифровать или перебирать все ключи. Потом путь к файлу. Для первых двух режимов - ключ. Для brute force создам папку и буду сохранять файлы для каждого ключа.

Начну с того что опишу строку с алфавитом. Потом метод который берёт символ и ключ, возвращает зашифрованный символ (если это символ из алфавита) или оставляет как есть. Потом буду читать файл построчно, обрабатывать и писать в новый файл.

Вроде всё можно сделать. Главное - не запутаться в индексах при сдвиге и не забыть про ошибки (если файла нет или ключ не число). В общем, работа понятная, но нужно аккуратно всё сделать.

Еще нужно продумать как будет устроена программа. Поскольку проект учебный, архитектура должна быть простой но понятной. Начну с того что создам основной пакет com.javarush.lipin.cryptoanalyzer - так требует задание.

Самый очевидный класс - Main. Он будет точкой входа, откуда всё запускается. Но сам по себе не должен содержать много логики - просто запустит интерфейс.

Нужно сделать отдельный класс для консольного интерфейса - назову ConsoleUI. Он будет общаться с пользователем: показывать меню, принимать команды, запрашивать пути к файлам и ключи. Тут же проверять ввод - что файл есть, что ключ число и т.д.

Саму логику шифрования и дешифрования вынесу в отдельный класс CaesarCipher. Там будет константа с алфавитом (33 русские буквы и символы пунктуации) и методы encrypt и decrypt, которые принимают текст и ключ, возвращают преобразованный текст. Логика сдвига по алфавиту будет там же.

Добавляю логику работы с регистром в CaesarCipher. Для каждого символа проверяю - если это буква и она в верхнем регистре, запоминаю это, работаю с нижним регистром, а потом восстанавливаю регистр.

Для brute force сделаю отдельный класс BruteForce. Его задача - перебрать все возможные ключи (от 1 до длины алфавита минус 1), для каждого ключа вызвать CaesarCipher.decrypt и сохранить результат в файл. Чтобы не засорять текущую папку, создам подпапку с результатами, а в имени файла укажу ключ.

Работу с файлами (чтение и запись) вынесу в утилитарный класс FileService. Он будет содержать методы которые принимают путь к файлу и возвращают/сохраняют текст. Там же обработка ошибок ввода-вывода.

Получится такая цепочка: Main запускает ConsoleUI, тот в зависимости от выбора пользователя вызывает либо CaesarCipher, либо BruteForce, а они используют FileService для работы с файлами.

Кажется это достаточно простая и логичная структура. Все компоненты разделены, каждый отвечает за свою задачу. Если позже захочу добавить новый метод шифрования, нужно будет просто создать новый класс аналогичный CaesarCipher и добавить пункт в меню ConsoleUI.

Начну с самого простого - класса FileService, потом CaesarCipher, затем BruteForce, и в конце уже займусь консольным интерфейсом. Так наверное проще тестировать каждую часть отдельно.

Теперь нужно разобраться с алгоритмами которые будут внутри программы. Начну с самого главного - как преобразовывать отдельные символы.

Представляю алфавит как строку со всеми символами которые нужно шифровать: "абвгдеёжзийклмнопрстуфхцчшщъыьэюя.,":-!? " (41 символ). Когда приходит символ, сначала проверяю есть ли он в этой строке. Если нет - просто возвращаю его как есть. Это касается цифр и других символов не входящих в алфавит.

Если символ есть в алфавите, нахожу его позицию. Допустим буква "б" имеет индекс 1. Затем прибавляю ключ. Скажем ключ равен 3. Получаю новую позицию 4 - это буква "д". Но что если ключ большой, например 100? Тогда нужно использовать операцию модуля чтобы "зациклить" позицию в пределах алфавита. Так же и с отрицательными ключами - при дешифровании буду вычитать ключ, и если получается отрицательное число, прибавлю длину алфавита перед взятием модуля.

Для всего текста это будет выглядеть как цикл по каждому символу. Беру символ, применяю преобразование, добавляю результат в новую строку. Постепенно собираю весь преобразованный текст.

С brute force всё довольно просто. У меня есть зашифрованный текст. Перебираю все возможные ключи от 1 до (длина_алфавита - 1). Для каждого ключа вызываю процедуру дешифрования и сохраняю результат в файл. Количество файлов будет равно количеству ключей, то есть 40 для алфавита из 41 символа.

Вроде алгоритмы получаются простыми и понятными. Главное - аккуратно обработать граничные случаи и помнить про модульную арифметику.

Начинаю писать код. Начну с самого простого - класса FileService. Сделаю его утилитарным, со статическими методами, так как не нужно хранить состояние. Для чтения и записи файлов использую класс Files из Java NIO.

Далее CaesarCipher. Определю алфавит как константу - 33 русские буквы и символы пунктуации. Сделаю два основных метода: encrypt и decrypt. Внутри буду использовать StringBuilder для результата. Главная логика - для каждого символа проверять есть ли он в алфавите, и если есть, применять сдвиг с учётом модульной арифметики.

Для BruteForce сделаю перебор всех возможных ключей. Для каждого ключа буду вызывать дешифровку и сохранять результат в файл. Чтобы не засорять директорию, где находится зашифрованный файл, создам в ней подпапку. Добавлю вывод прогресса в консоль чтобы пользователь видел что программа работает.

Самый сложный наверное будет ConsoleUI - нужно сделать удобный интерфейс с обработкой ошибок ввода. Сделаю бесконечный цикл меню где пользователь может выбирать операции. При ошибках буду выводить сообщения и предлагать повторить ввод.

Начну реализацию с нижних уровней - FileService, потом CaesarCipher, затем BruteForce, и только потом ConsoleUI и Main. Так смогу тестировать каждый компонент отдельно.

Важно не забывать про обработку ошибок на всех уровнях. Файловые операции, некорректный ввод пользователя, ошибки в алгоритмах - всё нужно обрабатывать и давать понятные сообщения.

Чувствую что постепенно всё складывается в единую картину. Главное - не торопиться и тестировать каждый шаг.

Подхожу к завершению проекта. Теперь нужно оформить всё правильно - написать документацию, проверить код и подготовить для загрузки в Git.

Документация - это важно. Хочу сделать понятный README файл, где будет описание проекта, как его собрать и запустить, какие функции есть. Еще сделаю файл notes.md с этими заметками.

Хочу добавить понятные комментарии в код, такие как в JavaDoc. Когда просматривал как работают методы в Intellij IDEA, мне сильно понравились коментарии зеленого цвета со звездочками описывающие работу классов и методов. Пожалуй разберусь как их праильно писать и сделаю, но позже.

Прошла неделя, а я только вчера посмотрел лекцию, где ментор разбирал проекты. Оказывается, я, как и некоторые однокурсники, не правильно оформили название проекта на GitHub. Поэтому мой проект не был рассмотрен. Исправил сей недочет. Также немного причесал код. 

До дедлайна осталось два дня. На оформление классов как JavaDocs уже нет времени. Но думаю успею реализовать статический анализ. И для начала нужно разобраться, что такое статистический анализ.

Ментор посоветовал улучшить структуру проекта - разнести классы по логическим пакетам. До этого все классы были в одном пакете, что работало для небольшого проекта. Создал новую структуру пакетов.

- `controllers` для ConsoleUI - он управляет взаимодействием с пользователем
    
- `services` для бизнес-логики, разделил на подпакеты:
    
    - `encryption` для алгоритмов шифрования (CaesarCipher)
        
    - `analysis` для методов анализа (BruteForce)
        
    - `file` для работы с файлами (FileService)
        

Пришлось поправить импорты во всех классах, но это того стоило. Теперь код выглядит более профессионально и его легче поддерживать.
